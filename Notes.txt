How it works in Java?
Source code converted to bytecode (sequences of 0's and 1's) by compiler, and then Java virtual machine (JVM) reads the bytecode

Name of Interface must be an adjective: like Runable,Readable,Remote etc

Class name must be noun like Student, Person,Computer,Hashmap etc

Method name mut be verb like actionPerfomrmed,run,print,write

By default 0 is taken as the  value for int etc ratherthan garbage values

Main method is static because in java, to call a mathod we need an object, but we don't have an object at the start of our program so we create a static method and static methods don't require an object to be called

We cannot use a non-static variable in a static block

Java doesn't support multiple inhertitance (due to ambiguity problem) , but C++ supports Multiple InheritanceDemo

Dynamic method dispactch in Java is a facny name for runtime polymorphism, if I use reference (LHS) of parent class but object of child class (on RHS), it is called runtime polymorphism. A obj=new B(); 

Wrapper classes provide a way to use primitive data types (int, boolean, etc..) as objects.

The table below shows the primitive type and the equivalent wrapper class:

Primitive Data Type	Wrapper Class
byte	Byte
short	Short
int	Integer
long	Long
float	Float
double	Double
boolean	Boolean
char	Character

Java automatically does a conversion of primitive data types into their wrapper classes when assigned. It is called boxing.

public class MyFirstJavaProgram {
   public static void main(String []args) {
      Integer testData = 10; //boxing
      System.out.println(testData);
   }
} (concept of boxing is there in JS also)


Unboxing on the other hand refers to converting an object of a wrapper type to its corresponding primitive value. For example conversion of Integer to int


Autoboxing is the process by which a primitive type is automatically encapsulated (boxed) into its equivalent type wrappers whenever an object of the type is needed. There is no need to construct an object explicitly. Like Integer value=5 will internally create the object using Integer value=new Integer(5) 

Some frameworks in Java work only with wrapper classes and not with primitive data types like int


Abstract class: is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class). Abstract method: can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).

In order for a function to be abstract, the corresponding class must also be abstract 

abstract class Human{
    public abstract void eat();
    public void walk(){

    }
}
class Man extends Human{ //this class is known as concrete class
    public void eat(){

    }
}

Example of asbtract Keyword used in Java...class Integer and Float implement the abstract class Number

Final Keyword in Java: Final keyword can be used with methods, classes and variables

Final variable is constant in nature, it's value can't be changed 

There can be use cases where we want to create a final class, a final class cannot be inherited by any other child class

If I declare a method as final,  then this method can't be overriden by any child class. 

===Interface and abstract class===
Interface is same as abstract class, but in abstract class we can have both asbtract methods as well as non-abstract methods, but in case of interface we cannot have non-abstract methods

For interface we use the keyword "implements" and for abstract class, we use the keyword "extends", the benefit of using interface is that in Java we can't have multiple polymorphism so we can't extend from two classes A,B but we can implement an interface and extend a class, something like class B implements A extends Character

Also, in interface we cannot define any method, like public void func(){ ....code .... } will give error, in an interface we can only declare the function, but in case of abstract class we can define the method too like public void speak(){ "Hello this is a general animal speaking" }

Another use case of interfaces in Java: let's say a manager wants to explain what all functionalities he wants in the project, he can give an interface with all the function declarations, so that the other person can come to know what he needs to implement.

Concept of Anonymous inner class: if I want to override a function show() of A, one way is to create a class B extends A and then define the show function inside it, another way is to define an anonymous inner class, something like

obj A=new A(){
    public void show() {...code...}
}

Just like abstract class, we can only create reference of abstract class, we cannot create object of interface.
